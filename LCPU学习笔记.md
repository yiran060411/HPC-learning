# 学习笔记

# **LCPU**学习笔记

## 基础部分

### 计算机基础知识

---

**CPU**:CPU 是整个计算机的核心，承担着运算和控制的功能。CPU 从存储设备中读取代码和数据，尽管现代处理器对代码和数据会有不同的处理，但是其本质上并没有严格的区分。代码由一条一条的指令组成，CPU 按照顺序一条一条执行从存储设备中读取的指令（至少从软件和程序员等使用者的视角看是这样），指令可以是修改 CPU 的状态，进行运算，或者是从其他硬件读取信息或者输出信息。

---

**内存**:内存是 RAM(Random Access Memory)，断电丢失数据的随机存储器,是处理器 CPU 能够直接访问到的数据存储器。而随机存储器中“随机”的意思是不论拿什么编号来找数据，所需时间总是差不太多的。

---

**硬盘**:有时候也被称作“内存”或者“外存”，断电数据不丢失的可以反复改写的存储设备。

分为机械硬盘HDD和固态硬盘SSD两种,一般来说，固态硬盘较贵，速度较快，抗振动辐射，而机械硬盘较为廉价，但速率较低，不过相对固态硬盘数据存放稳定性较好。

**GPU**:Graphics Processing Unit, 也叫做显卡，有独立显卡和集成显卡两种，前者以一种通过 PCIe 接口连接的扩展卡或直接独立集成在主板(通常存在于笔记本或者一体机内)的形式存在，而后者直接存在于处理器 SoC 内部(故名集成)。

<aside>
💭

PCIe（PCI Express）是一种高速串行计算机扩展总线标准，用于将显卡等外部设备连接到计算机主板。它是传统PCI总线的继任者，提供更高的数据传输带宽和更好的性能。

</aside>

<aside>
👺

SoC (System on Chip) 是一种将多个计算机组件（如CPU、GPU、内存控制器等）集成在单个芯片上的集成电路系统。在这里特指集成了显卡功能的处理器芯片。

</aside>

CPU 擅长控制和逻辑，单核处理能力强得多，适合各种通用的场合; 而 GPU 仅适用于并行且逻辑简单的计算，以其独特的架构取胜。

严格来说，GPU 是显卡上面主要的计算芯片，也可集成在 CPU 中，但是人们经常混用两个概念，我们在此也不严加区分。

---

**主板**:将各种硬件连接在一起，形成一个电路系统，为主芯片的工作提供各类条件支持(如供电降压，数据的传输，机械支撑，芯片工作顺序的控制等)，提供固件进行硬件自我检查和系统初始化，保存各个硬件的配置等。

---

**进程**:一个进程(Process)包含了一个程序运行的全部状态和属性。这也是冯诺依曼机的核心思想，当你获得了程序在内存以及寄存器中的状态也就得到了一切。

---

**线程**:线程(Thread)是轻量级的进程，一个进程可建立多个线程子程序任务同时执行。一般进程具有处理器和内存地址的隔离，而一个进程下的线程仅有处理器的隔离，虚拟内存地址是共用的，不同线程之间的通信成本要比进程之间小很多。

---

**例外**:例外(Exception)，有些时候翻译为异常(此处异常通常指代 abnormality，对于硬件系统中通常异常不等于错误)，通常后者称呼使用更多(后续使用异常这一称呼)。

可以发生于硬件层面,也可发生于软件层面。

<aside>
😁

中断(Interrupt)   陷阱(Trap)   故障(Fault)   终止(Abort)

</aside>

---

**操作系统**:

Windows是微软公司开发的图形化操作系统，具有成熟的图形界面。

Linux 只是一个“操作系统内核”，并没有包含用户态的程序，而一般来说，一个完整的操作系统需要包含用户态的一些基础设施，比如供更上层应用程序使用的库函数，以及用于管理其他软件和硬件，但不必放进内核态的程序。目前说 Linux 操作系统，一般指的是基于 Linux 内核衍生的各大发行版。

与 Windows 内核（名字是 NT 内核）不同，Linux 内核并不直接提供图形界面，只提供了最基本的各个接口，Linux 发行版的图形界面属于用户态程序，且是选配的。

**程序的执行**:

机器码与汇编 → 编译 → 链接 → 可执行文件 → 动态链接 → 程序的加载与结束

<aside>
👁️

机器码与汇编是程序代码的最底层形式。机器码是CPU直接执行的二进制指令，而汇编语言是机器码的人类可读形式，它使用助记符来表示机器指令。从程序执行流程来看，这是程序代码最初始的形态，之后才进入编译和链接等阶段。

<aside>
🥴

编译是将高级编程语言代码转换为机器码或汇编语言的过程，是程序从源代码到可执行文件转换过程中的关键步骤。

<aside>
📖

链接是程序构建过程中的一个阶段，它将编译后的目标文件和库文件组合成最终的可执行文件，处理各种符号引用并确定程序中各个部分的内存布局。位于编译之后，程序加载之前的步骤。

<aside>
🫥

动态链接是程序执行过程中一种链接方式，它允许程序在运行时才加载和链接所需的库文件，而不是在编译时就完全链接。这种方式可以节省内存并允许多个程序共享同一个库文件。

</aside>

</aside>

</aside>

</aside>

---

**计算机网络**:

**OS/I 七层模型**

| 层级 | 层名 | 主要功能 | 典型协议/设备 |
| --- | --- | --- | --- |
| 7 | 应用层 | 为应用程序提供网络服务 | HTTP, FTP, SMTP |
| 6 | 表示层 | 数据格式转换与加密 | JPEG, ASCII, SSL |
| 5 | 会话层 | 建立、管理和终止会话 | SSH, RPC |
| 4 | 传输层 | 端到端的数据传输控制 | TCP, UDP |
| 3 | 网络层 | 数据包的路由和转发 | IP, ICMP, 路由器 |
| 2 | 数据链路层 | 相邻设备间的数据传输 | 以太网, 交换机 |
| 1 | 物理层 | 比特流的传输 | 网线, 集线器 |

---

**TCP/IP 协议**

IP 协议为世界上每一个能连入全球互联网的设备分配一个地址，同时提供不可靠的包交换服务。

<aside>
😍 数据包指的是一段长度有限（但不总是固定）的数据。

</aside>

<aside>
⏰ 不可靠的包交换意思是把数据包从出发地传送到目的地，但是不保证包按照顺序到达，不保证有且仅有一个包到达，不保证包内容正确。

</aside>

IP 协议目前有两个版本：

IPv4，其地址由点分十进制，也就是类似于 111.111.111.111 的形式表示，每个十进制范围是 0-255，IPv4 也只能为最多 4294967296（42 亿）个设备分配唯一地址，已经接近枯竭，目前的缓解办法包括 NAT 等协议使得多台设备共用一个公网 IP。

IPv6，其地址由冒号分隔的 16 进制组成，长度是 128bit。如果地址中存在连续多项 0，可以用两个冒号替代，但是只能替代一次。

---

TCP利用 IP 协议提供的不可靠数据传输，为上层提供流式的端到端可靠数据传输。

与 TCP 同层还有 UDP 协议。UDP 协议不提供可靠传输服务，无状态，适合对数据准确性要求不高但是追求数据快速到达的场景，也适合上层实现别的可靠传输协议。

---

DNS(Domain Name System)协议是用于解析域名信息的协议，将域名转化为 IP 地址。

---

**能耗与功耗**：功耗是芯片单位时间消耗的电能，而能耗是芯片消耗单位电能完成的工作量。

**性能**：为了衡量一个 CPU 性能如何，人们开发了基准测试程序，也叫 Benchmark。

<aside>
👿 常见的 Benchmark 有如 Geekbench，Passmark，Spec2017，Cinebench，Blender Benchmark 等。 Spec2017 包括浮点和整数两个部分，前者包含如 gcc 编译器，h264 视频编解码，后者包含如 imagick 图像处理和各类科学计算等。

</aside>

GPU 相比通用处理器具有巨大的性能提升(从而极大的降低了成本，一张显卡的算力可以与百余核高端通用处理器相当，且相当便宜！)，而在另一些任务中相差甚远，几乎不能完成。 

**成本**：成本包括制造成本和运作成本，而利润是系统运行创造的价值除以其总成本减一。

制造成本主要是指购买一件设备的单次投资，通常其包含了生产的成本与其他的支持成本(如配套的操作系统和软件的研发与生态的维护)。

运作成本，在互联网大型数据中心是极为重要的，其包括电费，网费，冷却的费用(如空调费)，地皮空间的租金，以及设备损毁更换的开销等。

**计算机层次化**：简单性   模块化   标准化

---

**程序的编写**：

![processOfCoding.DcUYc1MV.png](processOfCoding.DcUYc1MV.png)

python 等**解释型**语言，只有解释器。

编辑是敲代码，编译是编译器将代码翻译成二进制。

---

**常用快捷键和指令**：

- `Ctrl+Shift+C/V`：终端中的复制和粘贴。注意，它与常用的复制粘贴快捷键不同。在 Windows 中，你也可以直接选中文本，然后右键复制。
- `Ctrl+C`：请求终止程序并释放内存。程序也可以选择做一些清理之后退出或者不响应此操作。
- `Ctrl+Z`：请求暂停程序，不释放内存，后续可以恢复执行。程序同样可以做清理或者不响应此操作。

---

**文本和文件**：

**1.文件本质**

在各个操作系统中，我们都可以把文件理解为一堆二进制数据的集合——它是计算机存储系统中的基本单位，用于存储数据和信息。

无论文件的类型或内容是什么，计算机存储和处理的所有数据最终都表示为**二进制形式**，即由 0 和 1 组成的比特序列。

打开文件时，选用的不同种字符编码，实际上就是告诉计算机用什么**标准**去读取文件，并按对应的规则显示为字符。

**2.文件后缀**

文件的后缀是文件**命名**的一部分，文件后缀与文件的**具体内容**无关，改变它并不会改变文件的内容——归根结底，它只是名字的一部分而已。

- **文本和文档档**：`.txt`、`.doc`、`.docx`、`.xls`、`.xlsx`、`.ppt`、`.pptx`。前者是记事本文件，后面则是 Word、Excel、PowerPoint 软件的文件格式。
- **源代码**：C++：`.cpp`、`.cc`、`.cxx`、`.hpp`、`.hxx`
    
     C：`.h`、`.c`
    
     Python：`.py`
    
    源代码文件都可以用记事本打开。它们的本质都是文本。
    
- **视频文件**：`.mp4`、`.avi`、`.mkv`、`.ts`、`.m3u8` 等。
- **图片**：`.jpg/.jpeg`、`.png`、`.gif`、`.bmp`、`.webp`、`.svg` 等。
- **压缩文件**：`.zip`、`.rar`、`.7z` 等。常用于 Linux 系统的有：`.tar.gz`、`.tar.xz`。常用于 macOS 系统的有：`.dmg`（用于分发软件）。用于光盘，或虚拟光盘的为：`.iso`，可用来存放系统镜像。
- **可执行文件**：Windows：`.exe`；Linux/Unix：无；MacOS：无，或 `.app`；Java 程序：`.jar`
- **脚本文件**：Windows：`.bat`、`.cmd`、`.ps1`；Linux/Unix：`.sh`

**3.文件系统**

- 文件系统上的一些概念
1. 目录（文件夹）
2. 文件路径：绝对路径   相对路径
3. 元数据
- 文件系统部分功能
1. 管理文件权限
2. 文件操作
3. 挂载和卸载
- 常见操作系统
1. **FAT32**：一种较老的文件系统，广泛用于 USB 闪存驱动器和存储卡。
2. **NTFS**：是 Windows 操作系统的默认文件系统，支持大文件和高级功能。
3. **ext4**：Linux 操作系统常用的文件系统，支持大文件和高性能。
4. **APFS**：苹果公司为 macOS 和 iOS 开发的文件系统，支持加密和快照。

---

**4.文本**

**纯文本**，在各类系统中可以使用 `txt` 后缀来区分，基本只有单纯的显示字符的功能，没有其他额外功能。实际上，各类后缀的**源代码**本质也是此类文本。

- 文本编码
- 文本字体

**5.创建文件**

---

**软件的安装与卸载**

---

**常见故障排查**

- 蓝屏
- 内核恐慌
- 应用软件崩溃
- 系统启动慢
- 应用程序慢
- 网络连接障碍

---

**用户界面——CLI   TUI   GUL**

**UI (User Interface)，用户界面**，则是直接涉及到用户应该如何与操作系统（或者是其他的软件）进行交互的核心模块。
**CLI (Command Line Interface，命令行界面)、TUI (Terminal User Interface/Text-based User Interface，终端用户界面/基于文本的用户界面)** （CLI 是早期大部分计算机的交互方式，而 TUI 可以部分视作在 CLI 的基础上进行了丰富)。

---

**集成开发环境和文本编辑器**

**IDE (Integrated Development Environment, 集成开发环境)，**IDE 提供代码编辑、调试、构建、版本控制等多种功能于一体，通常集成了编译器、调试器和其他开发工具。

**文本编辑器，**代码编辑器功能相对单一，通常只提供代码高亮等与代码编辑相关的功能。

严格来说在代码编辑器中无法运行代码，而需要在终端中手动输入编译相关的指令才能让代码“跑起来”。

---

**命令式语言**

**编译型语言:**源代码翻译成汇编代码(**编译器**）→   由**链接器**进行与头文件的整合  →  可以被直接运行的可执行文件

<aside>
😄

好处：一份需要被反复运行的代码只需要被编译一次，节省了编译部分的耗时。

</aside>

**解释型语言:**解释器允许代码一边被翻译为汇编语言一边被执行。

---

**Linux 与服务器介绍与基本使用**

**文件的权限:**用权限位 4、2、1 （二进制下第 3 2 1 个 bit ）代表读、写、执行的权限，每个文件的读、写、执行，对应当前用户、组内用户以及其他用户组成的 3*3 矩阵。

<aside>
☎️

**可执行文件并不是因为这个文件本身有什么特别，而是这个文件被你赋予了可执行的性质。**

</aside>

**一些常见指令**

```jsx
ls -l           # 以长格式显示当前目录中的文件和目录
ls -a           # 显示当前目录中的所有文件和目录，包括隐藏文件
ls -lh          # 以人类可读的方式显示当前目录中的文件和目录大小
ls -t           # 按照修改时间排序显示当前目录中的文件和目录
ls -R           # 递归显示当前目录中的所有文件和子目录
ls -l /etc/passwd     # 显示/etc/passwd文件的详细信息
```

创建文件

```jsx
touch [-acfm][-d<日期时间>][-r<参考文件或目录>][-t<日期时间>][--help][--version] [文件或目录]
```

复制文件

```jsx
cp [options] source dest
```

源文件  →  目标文件  【若目标文件不存在则会新建一个（此时作用相当于备份），若目标文件存在则会替换（此时相当于替换）】

```jsx
a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于 dpR 参数组合。
-d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。
-r 或 --recursive：用于复制目录及其所有的子目录和文件，如果要复制目录，需要使用该选项。
-i 或 --interactive：在复制前提示确认，如果目标文件已存在，则会询问是否覆盖，回答 y 时目标文件将被覆盖。。
-u 或 --update：仅复制源文件中更新时间较新的文件。
-v 或 --verbose：显示详细的复制过程。
-p 或 --preserve：保留源文件的权限、所有者和时间戳信息。
-f 或 --force：强制复制，即使目标文件已存在也会覆盖，而且不给出提示。
-l：不复制文件，只是生成链接文件。
```

移动文件

```jsx
mv [options] source dest
```

源文件  →  目标文件  

<aside>
📖

`cp` 与 `mv` 操作的文件路径都可以是相对路径或绝对路径

</aside>

```jsx
b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。
-i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。
-f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。
-n: 不要覆盖任何已存在的文件或目录。
-u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。
```

显示当前进程状态

```jsx
ps [options] [--help]
```

```jsx
-help 查看帮助
-A 列出所有的进程
-au 显示较详细的资讯
-aux 显示所有包含其他使用者的进程
```

查找指定进程的格式：

```jsx
ps -ef | grep 进程关键字
```

**解压缩**

.tar:

```jsx
解包：tar -xvf FileName.tar
打包：tar -cvf FileName.tar DirName
```

.gz:

```jsx
解压1：gunzip FileName.gz
解压2：gzip -d FileName.gz
压缩：gzip FileName
```

.tar.gz 和 .tgz

```jsx
解压：tar -zxvf FileName.tar.gz
压缩：tar -zcvf FileName.tar.gz DirName
```

.bz2

```jsx
解压1：bzip2 -d FileName.bz2
解压2：bunzip2 FileName.bz2
压缩： bzip2 -z FileName
```

.tar.bz2

```jsx
解压：tar -jxvf FileName.tar.bz2
压缩：tar -jcvf FileName.tar.bz2 DirName
```

.zip

```jsx
解压：unzip FileName.zip
压缩：zip FileName.zip DirName
```

.rar

```jsx
解压：rar -x FileName.rar
压缩：rar -a FileName.rar DirName
```

**文本编辑**

vi/vim 分为三种模式：命令模式（普通模式）、输入模式、命令行模式（底线命令模式）

命令模式下:

```jsx
i  -- 切换到输入模式，在光标当前位置开始输入文本。
x  -- 删除当前光标所在处的字符。
:  -- 切换到底线命令模式，以在最底一行输入命令。
dd -- 剪切当前行。
yy -- 复制当前行。
p  -- 粘贴剪贴板内容到光标下方。
P  -- 粘贴剪贴板内容到光标上方。
u  -- 撤销上一次操作。
Ctrl+r -- 重做上一次撤销的操作。
```

输入模式通过在命令模式按'i'进入，按 Esc 则返回普通模式

底线命令模式在命令模式下按':'进入:

```jsx
:w  -- 保存文件。
:q  -- 退出 Vim 编辑器。
:wq -- 保存修改并退出 Vim 编辑器。
:q! -- 不保存修改强制退出 Vim 编辑器。
```

---

**虚拟机的配置及使用**

**WSL 的命令**

查看当前的 WSL 的状态

```bash
wsl -l -v
```

关闭所有正在运行的 WSL 发行版与 WSL2 虚拟机

```bash
wsl --shutdown
```

转换指定 Linux 系统的 WSL 版本（需要关机状态下）

```bash
wsl --set-default <Distribution Name>
```

这几个命令一般连用，可以将原本放在 C 盘指定位置的 WSL 文件导出到其他盘

```bash
wsl --export <Distribution Name> <FileName>
wsl --export Ubuntu D:\WSL\Ubuntu.tar
wsl --unregister <Distribution Name>
wsl --unregister Ubuntu
wsl --import <Distribution Name> <InstallLocation> <FileName>
```

改变 WSL 的安装位置， FileName 与先前所填的相同，InstallLocation 写新 WSL 安装目录

```bash
wsl --import Ubuntu D:\WSL\Ubuntu D:\WSL\Ubuntu.tar --version 2
```

---

**远程连接与远程文件传输**

**SSH**

SSH 全称 Secure Shell，是一种网络协议，用于加密两台计算机之间的通信，并且支持各种身份验证机制。

软件架构为服务器-客户端模式（Server-Client），分成两个部分：

向服务器发出请求的部分【客户端（client）】，OpenSSH 的实现为 `ssh`；

接收客户端发出的请求的部分【服务器（server）】，OpenSSH 的实现为 `sshd`。

---

**文本编辑:Markdown,LATEX和Typst**

**Markdown 是一种轻量级的标记语言，可用于在纯文本文档中添加格式化元素。**

**LATEX是一种极为专业的排版工具，而不是文本编辑器。它的源文档与 Markdown 的简洁干净不同，而是充斥了各种各样的反斜杠，大括号和宏。**

---